__author__ = 'Kazem'
import csv
import os
import sys
import getopt
import collections
import matplotlib.pyplot as plt
import numpy as np
import fnmatch
from os.path import basename
from operator import itemgetter, attrgetter, methodcaller


def dir_contents(path, type):
    matches = []
    for root, dirnames, filenames in os.walk(path):
        for filename in fnmatch.filter(filenames, '*.'+ type):
            matches.append(os.path.join(root, filename))
    return matches

class fileRecord:
    def __init__(self, path, fileName, lostSamples):
        self.path = path
        self.fileName = fileName
        self.lostSamples = lostSamples
        self.paramDic = {}

    def addParamVal(self,param,val):
        if val != -1000:
            self.paramDic[param]=val

    def addLostItems(self,item):
        self.lostSamples=item


class visualizer:

    def __init__(self, path, pathOut):
        self.path = path
        self.pathOut = pathOut
        self.recordLists = []

    def populateFileList(self):
        # this function recursively find the CSV files and store
        # all the information in a record list
        fileList = dir_contents(self.path, 'csv')
        fNo = 0
        sep=";"
        for f in fileList:
            with open(f) as csvFile:
                firstLine = csvFile.readline().strip()
                #if file is empty
                if firstLine == "":
                    continue
                if firstLine[0]!="#":
                    continue
                firstLine = firstLine.split(":")[1]
                recordForOneF = fileRecord(self.path,f,firstLine)
                tfn = f.strip().split("/")
                fn=tfn[len(tfn)-1].split(".")
                recordForOneF.addParamVal("FileName",fn[0])
                initLine = csvFile.readline()
                while initLine != "":
                #for initLine in f:
                    splitted = initLine.strip().split("'")
                    key = splitted[1]
                    #sec line
                    initLine = csvFile.readline()
                    while initLine == "":
                        initLine = csvFile.readline()
                        if not initLine: break
                    splitted = initLine.strip().split(":")
                    all = int(splitted[1].strip())
                    #third line
                    initLine = csvFile.readline()
                    while initLine == "":
                        initLine = csvFile.readline()
                    splittedForTest = initLine.strip().split()[0]
                    #Probably zero sample, got to next block
                    if splittedForTest == "#":
                        recordForOneF.addParamVal(key, 0)
                        continue
                    splitted = initLine.strip().split(";")
                    percentage = float(splitted[0].strip().split("%")[0])
                    recordForOneF.addParamVal(key,all*percentage*0.01)
                    #fourth line, skip it
                    initLine = csvFile.readline()
                    cnt=0
                    while cnt < 20:
                        if len(initLine) > 0:
                            if initLine[0] != "#":
                                initLine = csvFile.readline()
                            else:
                                break
                        else:
                            cnt = cnt+1
                            initLine = csvFile.readline()
                            #if not initLine: break

                # Add it to the record list
                self.recordLists.append(recordForOneF)


    def writeCSV(self):
        fieldNames = []
        fieldNamesInit = []
        with open(self.pathOut, 'w') as csv_file:
            if len(self.recordLists) >0:
                for key, value in self.recordLists[0].paramDic.items():
                    fieldNamesInit.append(key)
                fieldNames = sorted(fieldNamesInit,key=str.lower)
                if "FileName" in fieldNames: fieldNames.remove("FileName")
                fieldNames.insert(0,"FileName")
            writer = csv.DictWriter(csv_file,fieldnames=fieldNames)
            writer.writeheader()
            for mydict in self.recordLists:
                writer.writerow(mydict.paramDic)

    #TODO
    def visualize(self, fileName, metric,outputPath):
        # Producing graphs for a metric over date. It can be a file with a frame-based metric. or throughput for a period. You don't need to specify the period.
        linestyles = ['-', '-*', ':', '-H', '-^', '-+', '-D', '-p', '-d']
        colors = ('b', 'g', 'r', 'c', 'm', 'y', 'k')
        sortedList = sorted(self.recordLists,key=attrgetter('dateNtime'))
        metricList = []
        metricDateList = []
        # Collecting the correct file records according to the given information.
        if fileName!='':
            for f in sortedList:
                if fileName == f.fileName:
                    for aType in f.algorithmType:
                        #if aType.name.strip().lower() == algorithm.lower():
                        if metric.lower() == 'psnr' and f.is_psnr:
                            metricList.append(aType.PSNR)
                            metricDateList.append(aType.name+' '+ f.dateNtime)
                        if metric.lower() == 'qi' and f.is_qi:
                            metricList.append(aType.QI)
                            metricDateList.append(aType.name+' '+ f.dateNtime)
                        if metric.lower() == 'mse' and f.is_mse:
                            metricList.append(aType.MSE)
                            metricDateList.append(aType.name+' '+ f.dateNtime)

            #Preparing the graph info
            maxMetricLen = 0
            if len(metricList) == 0:
                maxMetricLen = 0
            for m in metricList:
                if len(m) > maxMetricLen:
                    maxMetricLen = len(m)
            for mtrc in metricList:
                last = len(mtrc)
                while len(mtrc) < maxMetricLen:
                    mtrc.append(mtrc[last-1])
            xTicks = np.arange(maxMetricLen)
            i = 0
            axisNum = 0
            for linePlt in metricList:
                color = colors[axisNum % len(colors)]
                linestyle = linestyles[axisNum % len(linestyles)]
                tmpStyle = color+linestyle
                plt.plot(xTicks, linePlt[0:maxMetricLen],tmpStyle, label=metricDateList[i],markersize=10)
                i+=1
                axisNum +=1
            plt.legend()
            plt.grid()
            plt.xlabel('Frame Number')
            plt.ylabel(metric)
            plt.title('Quality Progress for file:'+fileName)
            mng = plt.get_current_fig_manager()
            mng.window.showMaximized()
            plt.show()
            if outputPath != '' and os.path.exists(outputPath):
                plt.savefig(outputPath+os.path.sep+metric.replace(" ","") +"OverTimeFor"+fileName+".png")
            else:
                print("Output path is not valid!")
        else:
            fileNoTable = [[0 for x in range(len(self.dateList))] for x in range(len(self.algorithmList))]
            timingTable = [[0 for x in range(len(self.dateList))] for x in range(len(self.algorithmList))]
            # Collecting the correct file records according to the given information.
            for f in self.recordLists:
                index1 = self.dateList.index(f.dateNtime)
                for aType in f.algorithmType:
                    index2 = self.algorithmList.index(aType.name)
                    timingTable[index2][index1] += aType.throughput
                    fileNoTable[index2][index1] += 1

            for i in range(len(self.algorithmList)):
                for j in range(len(self.dateList)):
                    if fileNoTable[i][j] != 0:
                        timingTable[i][j] = timingTable[i][j] /  fileNoTable[i][j]
                    else:
                        timingTable[i][j] = float('nan')

            #Preparing the graph info
            xTicks = np.arange(len(self.dateList))
            plt.xticks(xTicks, self.dateList)
            i = 0
            axisNum = 0
            for linePlt in timingTable:
                color = colors[axisNum % len(colors)]
                linestyle = linestyles[axisNum % len(linestyles)]
                tmpStyle = color+linestyle
                linPltSerie = np.array(linePlt).astype(np.double)
                linePltMask = np.isfinite(linPltSerie)
                plt.plot(xTicks[linePltMask], linPltSerie[linePltMask],tmpStyle, label=self.algorithmList[i], markersize=10)
                i +=1
                axisNum +=1
            plt.legend()
            plt.grid()
            plt.xlabel('Date')
            plt.ylabel('Average Throughput')
            plt.title('Optimization Progress')
            mng = plt.get_current_fig_manager()
            mng.window.showMaximized()
            plt.show()
            if outputPath != '' and os.path.exists(outputPath):
                plt.savefig(outputPath+os.path.sep+'AverageThroughput'+"OverTimeFor"+self.recordLists[0].folderName+".png")
            else:
                print("Output path is not valid!")



def main(argv):
    outputPath = ''
    inputPath = ''
    fileName = ''
    metric = ''
    algorithm = ''
    time1 = ''
    time2 = ''
    noiseType = 0
    try:
        opts , args = getopt.getopt(argv,"hi:o:f:m:s:e:",["help","inputPath=","outputPath=","fileName=","metric=", "time1=", "time2="])
    except getopt.GetoptError:
        print('visualize.py -i <inputPath> -o <output Path is optional> -f <File Name> -m <metric, QI, PSNR,..> '
              '-s <first time> -e <second time> ')
        sys.exit(2)
    for opt, arg in opts:
        if opt == '-h':
            print('visualize.py -i <inputPath> -o <output Path is optional> -f <File Name> -m <metric, QI, PSNR,..> '
                  '-s <first time> -e <second time>')
        elif opt in ("-i", "--inputPath"):
            inputPath = arg
        elif opt in ("-o", "--outputPath"):
            outputPath = arg
        elif opt in ("-f", "--fileName"):
            fileName = arg.strip()
        elif opt in ("-m", "--metric"):
            metric = arg.strip()
        elif opt in ("-a", "--algorithm"):
            algorithm = arg.strip()
        elif opt in ("-s", "--time1"):
            time1 = arg.strip()
        elif opt in ("-e", "--time2"):
            time2 = arg.strip()
    if inputPath != '':
        graphGenerator = visualizer(inputPath,outputPath)
        print ('Reading CSV files from the input directory: '+ inputPath)
        graphGenerator.populateFileList()
        if len(graphGenerator.recordLists) <= 0:
            print("Could not find any file record!")
            return
        print('Writing to '+ outputPath )
        graphGenerator.writeCSV()
    else:
        print('Please specify a path and right command arguments. You need at least a correct input path to see a graph')
        print('visualize.py -i <inputPath> -o <output Path is optional> -f <File Name> -m <metric, QI, PSNR,..> '
              '-s <first time> -e <second time>')

if __name__ == "__main__":
   main(sys.argv[1:])